Mechanical sympathy is about considering hardware when writing software to make their relationship more harmonious. It doesn't mean lots of repetitive imperative programming that would increase the complexity of the software. To benefit from both software and hardware, fundamental characteristics of the problems at hand are found to create specialised low-level pieces of software. Hardware functions in an imperative way so its likely these low-level parts will need optimisations to match. However, just as with a high-level programming language they are intended as abstractions to make the rest of the system more descriptive and so productive to write for.

Its more common in line-of-business software development to build upon general purpose sub-systems. This is understandable as the majority of such software is small in scope and has a short lifetime. Even the process of finding the characteristics that would benefit from specialisation has a cost. This combination often feeds back into the general purpose sub-system making its responsibilities more diverse and its implementation more complex. This is beneficial to those using it under the circumstances described as those responsibilities are easily accessible and the complexity remains hidden. Its more likely developers will be familiar with what's being used and so can quickly become productive. 

When software has more longevity and grows in terms of users and scope this may no longer apply. More users increases the potential to proportionally decrease hosting costs through optimisation and with more scope the potential of leveraging investment through re-use. Building upon large general purpose sub-systems will limit this ability to optimise and to integrate. Over time through supporting your system as it grows it will become necessary to understand how those sub-systems work revealing their complexity. Regardless of the whether what you depend upon is complex or simple, understanding its implementation is important to use it appropriately even if you have no intention of changing it.

Some of these problems can be mitigated in part by building upon open source general purpose sub-systems. By nature open source sub-systems are more likely to integrate with each other, but its less likely there'll be optimum cohesion across them. Depending on your employer you might be able to optimise by contributing, although this will be limited if you want to avoid adding complexity or forking. Unless there is already another complementary project to integrate with open source projects grow into diversification and so complexity.

I'd prefer to use open source libraries made up small mechanically sympathetic pieces to pick and choose from. Reducing the complexity of what's depend upon through it being more specialised while simultaneously making the domain code descriptive and less verbose.