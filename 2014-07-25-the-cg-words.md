Code generation has a bad reputation, and deservedly so. When used without discipline there can be bad code writing even more bad code. This can get churned out at an alarming rate, creating resistance to change and building up technical debit. At some point its going to need debugging... and probably the code that writes that code debugging. No wonder some would say its inexcusable.

# Acceptable face

A more excepted form is to do transformation, to create code representations of schemas (XML, database) or using code to make static things dynamic [Razor](http://www.asp.net/web-pages/tutorials/basics/2-introduction-to-asp-net-web-programming-using-the-razor-syntax)). The former is often done when your not the owner of the schema and must merely use it. Otherwise you could do things code-first, but then your just generating the schema instead. Either way, concepts modelled in the schema formats often won't have equivalents in a general purpose language. The success of using code generation to make things dynamic is reliant on the quality of the design experience and how elegantly code and the format can intermingle. Which is why in my experience something more specialised like Razor works better than T4 ([Text Template Transformation Toolkit](http://msdn.microsoft.com/en-us/library/bb126445.aspx)). However, its always frustrating when it'd be easy to change what's generated, but instead you have to plug away at the source file to try and replicate it.

# Learn joinery but don't throw out your nails

A common theme in those excepted forms is that the generator is provided for the developer. Widespread use of a generator and documentation can give a sense of security. The opposite end of the spectrum is where a developer uses the technique instead of language features to solve problems as a [golden hammer](http://en.wikipedia.org/wiki/Golden_hammer). However, sometimes limitations in a framework prevent doing things more appropriately. I've worked were Visual Studio's test framework is the standard, which has the limitation of requiring one method per named test. When a test has many cases, and in the same format, I use CSV (comma separated value) files to specify the actual and expected. This file then gets transformed with T4 into the test methods. However, I try and minimise what is generated and use partial classes for the test implementations. The ideal solution would be to use a another framework without the one method per named test limitation. This would allow the test code to run straight from cases and so remove the need for code generation.

# Jack of all trades

What if instead of a framework the limitations are in the programming language itself. Knowing the verity and flexibility of languages might mean you can choose one which matches your needs better (reading [Seven Languages in Seven Weeks](http://pragprog.com/book/btlang/seven-languages-in-seven-weeks) is a good start). However, when your being paid to integrate into a department, that might be less appropriate/likely. If you can demonstrate that a different unit test framework is advantageous to all, a healthy department should be able to change. However, opening up the possibility of having teams using many different languages is less straightforward. If the subject of development lends itself to a few then its use might be possible without overly restricting the ability for people to move between teams. Although out the box they're not the most customisable of languages, general purpose languages like C# do allow freedom in programming style (e.g. imperative to functional). This common grounding can help support verity without being too jarring as people move around the code-base. However, its not ideal and can often feel clumsy. If you're aware of the full spectrum of programming languages you often get feature envy.

# Code, code, code

I've found there isn't a language that best suits my needs, and that having written a lot of code and having an understanding of a wide range of languages, I know what I want. I write in what I'd describe as a structured functional style and C# comes close. However, even after building up my own library of general purpose methods for C# it needed something more, like Scala is to Java. Keeping in mind the nature of code generation I've described here, what I could turn all that on its head, with what is available now. Making it to easily generate concise well written C#, just like I was writing by hand, by having a clearly defined and reliable generator in C# which reads standard C#.

Follow up: [Generating what and when](2014-08-01-generating-what-and-when.md)
