I started writing a blog post a while ago to help developers think about how to split a system into higher level components, but I didn't finish it. However, it made me noticed a common theme in what other people wrote on the subject.

All the posts I've seen describe it in a prescriptive way. The assumption is that you use one architecture at a time. That new ones are evolutionary and progressively improve on the weaknesses of the last. This progress is shown normally as going from layering, through onion and hexagonal, onto ports and adapters. This mind set to improving how we go about componentisation isn't pragmatic. The evolution from layering highlights its inherent limitations. 

Layering is based on a technological taxonomy (e.g. a layer for UI, one for domain logic and one for database). I can understand where the desire to do this comes from, to reduce coupling to a platform, UI system or persistence. This approach can be successful for simple systems. Whether or not its practical to swap these technologies, I'll leave to your experience. This an technology focused approach, most developers don't write operating systems and concerns like these are cross cutting (i.e. span the whole system).

Unless your learning or experimenting, the vast majority of developers create software to provide functionality for users. Sometimes this is a very indirect and disassociated relationship, the users might be other developers, but its still the primary concern. So the most appropriate way to break-down from the higher level is to allow the specifics of the particular domain to drive the taxonomy. If you find there can be re-use of or decoupling from technologies at the lower levels think of it as a different dimension of separation.

If you are aware of DDD (domain driven design) my direction might sound similar. That has connotations of non-technical upfront design and so very unlike component architectures. Sometimes the most suitable structure for the code matches the concepts and process from domain directly. However, often its only when we implement, the system becomes tangible, we realise the complexity and so underlying hidden fundamental aspects reveal themselves.

One way of visualising the difference between the two might be to say component architectures are horizontal separation and DDD is vertical. We cannot combine both to make something grid-like. That would loose the shapes (like hexagons) that are used in the more advanced component architectures. If you use DDD to describe everything in a large system it must have sub-structures. I visualise using potentially infinitely sub-structures, but combine both domain and technical.

Developers can subscribe to architectures, I'm advocating they pragmatically employ different approaches. Approaches they understand the applicability of from experience. Applying them to the problem at hand which as developers only they can fully realize.